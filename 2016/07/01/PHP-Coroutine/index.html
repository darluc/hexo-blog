<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>用PHP协程实现多任务协作 | Z - Computer &amp; Programming Technology</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="PHP 5.5  中最重要的特性之一就是对协程（coroutine）和生成器（generator）的支持。生成器的特性已经由官方文档和许多博文（比如这一篇和这一篇）讲解得很充分了。另一方面，协程受到的关注则较少。这是因为协程的功能相较而言更加强大，但却难以讲解。
本文会使用协程实现一个任务调度器，以此帮助你理解协程的概念和用法。我会先用几个段落做一些介绍。如果你觉得你已经对生成器和协程的基本概念掌">
<meta property="og:type" content="article">
<meta property="og:title" content="用PHP协程实现多任务协作">
<meta property="og:url" content="http://log.zvz.im/2016/07/01/PHP-Coroutine/index.html">
<meta property="og:site_name" content="Z - Computer & Programming Technology">
<meta property="og:description" content="PHP 5.5  中最重要的特性之一就是对协程（coroutine）和生成器（generator）的支持。生成器的特性已经由官方文档和许多博文（比如这一篇和这一篇）讲解得很充分了。另一方面，协程受到的关注则较少。这是因为协程的功能相较而言更加强大，但却难以讲解。
本文会使用协程实现一个任务调度器，以此帮助你理解协程的概念和用法。我会先用几个段落做一些介绍。如果你觉得你已经对生成器和协程的基本概念掌">
<meta property="og:updated_time" content="2024-05-12T13:15:10.153Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用PHP协程实现多任务协作">
<meta name="twitter:description" content="PHP 5.5  中最重要的特性之一就是对协程（coroutine）和生成器（generator）的支持。生成器的特性已经由官方文档和许多博文（比如这一篇和这一篇）讲解得很充分了。另一方面，协程受到的关注则较少。这是因为协程的功能相较而言更加强大，但却难以讲解。
本文会使用协程实现一个任务调度器，以此帮助你理解协程的概念和用法。我会先用几个段落做一些介绍。如果你觉得你已经对生成器和协程的基本概念掌">
  
    <link rel="alternative" href="/atom.xml" title="Z - Computer &amp; Programming Technology" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.geekzu.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8NRBEZPWYN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8NRBEZPWYN');
</script>


  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-8768699638326268",
      enable_page_level_ads: true
    });
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-PHP-Coroutine" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      用PHP协程实现多任务协作
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/07/01/PHP-Coroutine/" class="article-date">
  <time datetime="2016-07-01T00:56:55.000Z" itemprop="datePublished">2016-07-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/tags/Coroutine/">Coroutine</a> <a class="article-category-link" href="/tags/php/">php</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>PHP 5.5  中最重要的特性之一就是对协程（coroutine）和生成器（generator）的支持。生成器的特性已经由<a href="http://de2.php.net/manual/en/language.generators.overview.php" target="_blank" rel="external">官方文档</a>和许多博文（比如<a href="http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html" target="_blank" rel="external">这一篇</a>和<a href="http://sheriframadan.com/2012/10/test-drive-php-5-5-a-sneak-peek/#generators" target="_blank" rel="external">这一篇</a>）讲解得很充分了。另一方面，协程受到的关注则较少。这是因为协程的功能相较而言更加强大，但却难以讲解。</p>
<p>本文会使用协程实现一个任务调度器，以此帮助你理解协程的概念和用法。我会先用几个段落做一些介绍。如果你觉得你已经对生成器和协程的基本概念掌握得很牢固了，那么你可以直接跳至“多任务协作”这一段开始阅读。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器背后最原始的想法就是一个函数不仅仅返回一次数据，而是能够返回一系列的数据，并且这些数据是挨个返回的。也可以理解为，生成器使你能更方便地实现迭代器。<code>xrange()</code> 函数就是一个生成器的简单例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span><span class="params">($start, $end, $step = <span class="number">1</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> ($i = $start; $i &lt;= $end; $i += $step) &#123;</div><div class="line">    <span class="keyword">yield</span> $i;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">foreach</span> (xrange(<span class="number">1</span>, <span class="number">1000000</span>) <span class="keyword">as</span> $num) &#123;</div><div class="line">  <span class="keyword">echo</span> $num, <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>上例中的 <code>xrange()</code> 函数与内置函数 <code>range()</code> 函数的功能相同。唯一的区别在于 <code>range()</code> 会返回一个包含了一百万个数字的数组，而 <code>xrange()</code> 则返回一个可以吐出这些数字的迭代器，不会去老实地计算出一个包含所有数字的数组。</p>
<p>这样做的好处是显而易见的。它使得你可以处理超大规模的数据，而无需一次性将它们载入内存。你甚至可以处理无穷无尽的数据流。</p>
<p>当然并不是只有生成器能做到这一点，你也可以通过实现一个 <code>iterator</code> 接口来完成同样的工作。生成器只是更加方便，避免你为了生成一个迭代器而不得不去实现该接口的五个不同方法。</p>
<h2 id="将生成器用作可中断函数"><a href="#将生成器用作可中断函数" class="headerlink" title="将生成器用作可中断函数"></a>将生成器用作可中断函数</h2><p>要从对生成器的理解过度到协程的概念，理解它们内部的工作方式是非常重要的：生成器是可中断的函数，而 <code>yield</code> 语句则构成了这些中断点。</p>
<p>接着刚才的例子，当你调用  <code>xrange(1, 1000000)</code> 时，实际上 <code>xrange()</code> 没有执行任何代码。取而代之地，PHP 仅返回了一个 <code>Generator</code> 类的实例，它实现了 <code>Iterator</code> 接口：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$range = xrange(<span class="number">1</span>, <span class="number">1000000</span>);</div><div class="line">var_dump($range); <span class="comment">// object(Generator)#1</span></div><div class="line">var_dump($range <span class="keyword">instanceof</span> Iterator); <span class="comment">// bool(true)</span></div></pre></td></tr></table></figure>
<p>只有当你调用 iterator 接口相关的方法时代码才会执行。例如，你执行 <code>$range-&gt;rewind()</code> 时，<code>xrange()</code> 函数中的代码就会执行，直到流程中的第一条 <code>yield</code> 语句。如此一来，就意味着 <code>$i = $start</code> 和 <code>yield $i</code> 被执行了。任何传递给 <code>yield</code> 语句的数据都能通过 <code>$range-&gt;current()</code> 来获取。</p>
<p>你需要调用 <code>$range-&gt;next()</code> 方法来继续执行生成器中的代码。这样它就会继续执行下去，直到下一条 <code>yield</code> 语句。所以只要连续地调用 <code>-&gt;next()</code> 和 <code>-&gt;current()</code> 方法，你就可以从生成器中获取到所有的返回值，直至最终不再遇到 <code>yield</code> 语句。对于 <code>xrange()</code> 函数来说，就是 <code>$i</code> 超出 <code>$end</code> 的时候。如此一来，流程会继续执行完剩余的代码，直至函数的结尾。若此时调用 <code>-&gt;valid()</code> 方法则会返回 false，这个迭代过程就结束了。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>相对于上述功能，协程最主要的一点就是加入了向生成器中发送数据的能力。这使得从生成器到调用者的单向数据流，变成了两者彼此往来的数据通路。</p>
<p>将数据传递给协程的方法是调用 <code>-&gt;send()</code> 方法，而不是 <code>-&gt;next()</code>。下面的这个 <code>logger()</code> 的例子展示了它是如何工作的：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span><span class="params">($fileName)</span> </span>&#123;</div><div class="line">  $fileHandle = fopen($fileName, <span class="string">'a'</span>);</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    fwrite($fileHandle, <span class="keyword">yield</span> . <span class="string">"\n"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$logger = logger(<span class="keyword">__DIR__</span> . <span class="string">'/log'</span>);</div><div class="line">$logger-&gt;send(<span class="string">'Foo'</span>);</div><div class="line">$logger-&gt;send(<span class="string">'Bar'</span>);</div></pre></td></tr></table></figure>
<p>如你所见，在这里 <code>yield</code> 没有被用作一个语句，而是作为一个表达式，也是就说它有一个返回值。这个返回值是通过 <code>-&gt;send()</code> 语句传过来的。此例中 <code>yield</code> 会先返回 ‘Foo’ 再返回 ‘Bar’。</p>
<p>上面的例子中 <code>yield</code> 仅仅只是作为一个接收者。实际上可以把两者结合起来，使其既可以发送也可以接收数据。例子如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</div><div class="line">  $ret = (<span class="keyword">yield</span> <span class="string">'yield1'</span>);</div><div class="line">  var_dump($ret);</div><div class="line">  $ret = (<span class="keyword">yield</span> <span class="string">'yield2'</span>);</div><div class="line">  var_dump($ret);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">var_dump($gen-&gt;current()); <span class="comment">// string(6) "yield1"</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret1'</span>)); <span class="comment">// string(4) "ret1" (gen 函数中的第一个 var_dump)</span></div><div class="line">						    <span class="comment">// string(6) "yield2" ( -&gt;send() 返回值的 var_dump)</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret2'</span>)); <span class="comment">// string(4) "ret2" (又是 gen 函数中的 var_dump)</span></div><div class="line">						    <span class="comment">// NULL ( -&gt;send() 的返回值)</span></div></pre></td></tr></table></figure>
<p>猛地一看，这些输出的顺序可能会有些难以理解，所以请多阅读几遍以确保你理解了它为何会如此输出。这儿有两点我要特别指出的：第一，使用括号将 <code>yield</code> 语句引起来不是随意为之的。由于技术原因这些括号是必须的。第二，你可能已经注意到了，我们在调用 <code>-&gt;current()</code> 之前没有调用 <code>-&gt;rewrind()</code> 方法。像这样做，rewind 操作实际被隐式的执行了。</p>
<h2 id="多任务协作"><a href="#多任务协作" class="headerlink" title="多任务协作"></a>多任务协作</h2><p>如果你看了上文 <code>logger()</code> 的例子，可能会想“为啥我要用协程做这事呢？为何我不直接用使用一个普通的类？”，当然你是绝对没错的。这个例子只是展示了协程的基本用法，但这样做却没有得到任何实际的好处。这只是许多协程示例中的一个而已。我已经说过协程是一个非常 NB 的概念，但是它们的应用却很少而且常常比较复杂，使得它很难举出一个简单而又不装的例子。</p>
<p>本文我决定用一个多任务协作的实现作为例子。目标是要能够并行地执行多个任务（或者“程序段”）。可是一个处理器只能处理一个任务（不考虑多核的情况）。这样一来，就需要处理器在多个不同的任务之间切换，让每一个任务都“运行一小会儿”。</p>
<p>“协作”的部分描述了这种切换的实现方式：它要求当前执行的任务自愿地将控制权返还给调度器，让其它的任务可以执行。这是相对于“优先调度“这种多任务调度方式而言的，优先调度方式下调度器可以在任务执行期间中断它，无论它是否自愿。协作式多任务被运用于早期版本的 Windows（Win95 之前）和 Mac OS，但之后它们都采用了优先调度的方式。原因很简单：如果你依赖于一个程序主动交出控制权，那么恶意软件就能很容易地占用全部的 CPU 资源，而不给其它任务留下任何执行的机会。</p>
<p>此时你应该可以看出协程和任务调度之间的关联了：<code>yield</code> 指令提供了一种方式，使得任务可以自我中断，将控制权交还调度器，让别的任务得以执行。而且 <code>yield</code> 指令还可以用于任务和调度器之间的数据交互。</p>
<p>对于我们的最终实现来讲，一个“任务”将会是对协程函数的简单包裹类：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> $taskId;</div><div class="line">  <span class="keyword">protected</span> $coroutine;</div><div class="line">  <span class="keyword">protected</span> $sendValue = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;taskId = $taskId;</div><div class="line">    <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskd;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendValue)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;sendValue = $sendValue;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</div><div class="line">      <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</div><div class="line">      <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">return</span> $retval;</div><div class="line">    &#125;  </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个任务是一个由任务 ID 标识的协程。使用 <code>setSendValue()</code> 你可以设定下一次获得执行时，传递给协程的数据（之后你会看到我们需要它做些什么）。<code>run()</code> 方法实际上什么都不用做，只是调用协程的 <code>send()</code> 方法。为了理解额外的 <code>beforeFirstYield</code> 属性，我们可以考虑以下的代码片段：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'foo'</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="string">'bar'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">var_dump($gen-&gt;send(<span class="string">'something'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 在 send() 发生时，在第一次 yield 之前，有一次隐式的 rewind() 调用</span></div><div class="line"><span class="comment">// 所以实际发生的过程是这样的：</span></div><div class="line">$gen-&gt;rewind();</div><div class="line">var_dump($gen-&gt;send(<span class="string">'something'</span>));</div><div class="line"></div><div class="line"><span class="comment">// rewind() 调用时会执行到第一个 yield 处(并且忽略它的值)，send() 调用时会前进至第二个 yield 处（并且抛出它的值）。这样的话，我们就会失去第一个 yield 的值！</span></div></pre></td></tr></table></figure>
<p>通过增加额外的 <code>beforeFirstYield</code> 属性，可以保证第一次 yield 的值也可以正确地返回。</p>
<p>调度器只需要循环执行这些任务即可：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>;</div><div class="line">  <span class="keyword">protected</span> $taskMap = []; <span class="comment">// taskId =&gt; task</span></div><div class="line">  <span class="keyword">protected</span> $taskQueue;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> SplQueue();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">    $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;</div><div class="line">    $task = <span class="keyword">new</span> Task($tid, $coroutine);</div><div class="line">    <span class="keyword">$this</span>-&gt;taskMap[$tid] = $task;</div><div class="line">    <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">    <span class="keyword">return</span> $tid;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;taskQueue-&gt;enqueue($task);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">      $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();;;</div><div class="line">      $task-&gt;run();</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</div><div class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>newTask()</code> 方法用于创建任务并把它放入任务对照表中。此外它把任务放入任务队列，以此来安排任务的执行。<code>run()</code> 方法用于遍历这个任务队列，并执行任务。如果一个任务完成了，那么它会被从队列中移除，否则它会被重新排在队列尾部。</p>
<p>让我们用两个简单（且无意义的）任务，来测试一下调度器：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>:</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">5</span>; ++$i) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"This is task 2 iteration $i.\n"</span>;</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line"></div><div class="line">$scheduler-&gt;newTask(task1());</div><div class="line">$scheduler-&gt;newTask(task2());</div><div class="line"></div><div class="line">$scheduler-&gt;run();;</div></pre></td></tr></table></figure>
<p>两个任务都是只是打印出一条信息，然后使用 <code>yield</code> 将控制权交还给调度器。以下是输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">This is task 1 iteration 1.</div><div class="line">This is task 2 iteration 1.</div><div class="line">This is task 1 iteration 2.</div><div class="line">This is task 2 iteration 2.</div><div class="line">This is task 1 iteration 3.</div><div class="line">This is task 2 iteration 3.</div><div class="line">This is task 1 iteration 4.</div><div class="line">This is task 2 iteration 4.</div><div class="line">This is task 1 iteration 5.</div><div class="line">This is task 2 iteration 5.</div><div class="line">This is task 1 iteration 6.</div><div class="line">This is task 1 iteration 7.</div><div class="line">This is task 1 iteration 8.</div><div class="line">This is task 1 iteration 9.</div><div class="line">This is task 1 iteration 10.</div></pre></td></tr></table></figure>
<p>与预期一致：前5次迭代两个任务是交替进行的，然后当第二个任务结束了，只剩下第一个在继续执行。</p>
<h2 id="与调度器进行交互"><a href="#与调度器进行交互" class="headerlink" title="与调度器进行交互"></a>与调度器进行交互</h2><p>至此调度器已经可以工作，我们就能开始进行下一事项了：任务与调度器的数据交互。我们将使用进程与操作系统之间一样的交互方法：系统调用（system call）。我们需要系统调用，是由于操作系统和进程应当运行在不同的特权级别。 所以为了进行某些特权操作（比如杀死其它的进程），必须得有方法将控制交给内核，让内核去执行。从内部看这又是通过中断指令来实现的。早期我们使用的是原生的 <code>int</code> 指令，现如今则有了更专业且更快速的 <code>syscall/sysenter</code> 指令。</p>
<p>我们的任务调度系统将会反应出这种设计：不是简单地将调度器传递给任务（这样会使得任务能够为所欲为），我们会通过 <code>yield</code> 表达式让它们以系统调用的方式进行交互。<code>yield</code> 在这里不仅起到中断的作用，同时也负责传递信息给调度器。</p>
<p>我们用一个 <code>callable</code> 对象的包裹类来描述一个系统调用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemCall</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> $callback;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__cosntruct</span><span class="params">(callable $callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;callback = $callback;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</div><div class="line">    $callback = <span class="keyword">$this</span>-&gt;callback; <span class="comment">// 不能从 PHP 中直接调用</span></div><div class="line">    <span class="keyword">return</span> $callback($task, $scheduler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会表现得如任何可调用对象一样（通过 <code>__invoke</code> 方法），但是让调度器将调用的任务和它自己一起传递至函数内。为了使用它，我们需要小小地修改一下调度器的 <code>run</code> 方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span>( !<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty() ) &#123;</div><div class="line">    $task = <span class="keyword">$this</span>-&gt;taskQueue-&gt;dequeue();</div><div class="line">    $retval = $task-&gt;run();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ($retval <span class="keyword">instanceOf</span> SystemCall) &#123;</div><div class="line">      $retval($task, <span class="keyword">$this</span>);</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</div><div class="line">      <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个系统调用什么都不做，只是返回任务 ID 号：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(<span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> </span>&#123;</div><div class="line">    $task-&gt;setSendValue($task-&gt;getTaskId());</div><div class="line">    $scheduler-&gt;schedule($task);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的实现方式是将 tid 设置为下一个发送的数据并且重排任务。对于系统调用，调度器并不自动重排任务，我们需要手动控制（后面你就会知道为什么）。我们可以利用系统调用重写之前的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">($max)</span> </span>&#123;</div><div class="line">  $tid = (<span class="keyword">yield</span> getTaskId()); <span class="comment">// &lt;-- 这里使用了系统调用</span></div><div class="line">  <span class="keyword">for</span> ( $i = <span class="number">1</span>; $i &lt;= $max; ++$i ) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"This is task $tid iteration $i.\n"</span>;</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line"></div><div class="line">$scheduler-&gt;newTask(task(<span class="number">10</span>));</div><div class="line">$scheduler-&gt;newTask(task(<span class="number">5</span>));</div><div class="line"></div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure>
<p>代码输出还是和之前一样。注意是如何进行系统调用的，基本上和普通函数一样只是前面多加了一个 <code>yield</code> 。下面还有两个系统调用分别用于创建任务和删除任务：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(</div><div class="line">    <span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> <span class="title">use</span> <span class="params">($coroutine)</span> </span>&#123;</div><div class="line">      $task-&gt;setSendValue($scheduler-&gt;newTask($coroutine));</div><div class="line">      $scheduler-&gt;schedule($task);</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">killTask</span><span class="params">($tid)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(</div><div class="line">    <span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> <span class="title">use</span> <span class="params">($tid)</span> </span>&#123;</div><div class="line">      $task-&gt;setSendValue($scheduler-&gt;killTask($tid));</div><div class="line">      $scheduler-&gt;schedule($task);</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>killTask</code> 函数的实现需要在调度器里加一个方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">killTask</span><span class="params">($tid)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;taskMap[$tid])) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$tid]);</div><div class="line">  </div><div class="line">  <span class="comment">// 这里的代码有点烂，其实可以优化让它不用遍历整个队列的，</span></div><div class="line">  <span class="comment">// 但我这里暂时不管它了，就假设杀进程不是那么常用的吧</span></div><div class="line">  <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;taskQueue <span class="keyword">as</span> $i =&gt; $task) &#123;</div><div class="line">    <span class="keyword">if</span> ($task-&gt;getTaskId() === $tid) &#123;</div><div class="line">      <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskQueue[$i]);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用下面一小段代码来测试新功能：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">childTask</span><span class="params">()</span> </span>&#123;</div><div class="line">  $tid = (<span class="keyword">yield</span> genTaskId());</div><div class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Child task $tid still alive!\n"</span>;</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">  $tid = (<span class="keyword">yield</span> getTaskId());</div><div class="line">  $childTid = (<span class="keyword">yield</span> newTask(childTask()));</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">6</span>; ++$i) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Parent task $tid iteration $i.\n"</span>;</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ($i == <span class="number">3</span>) <span class="keyword">yield</span> killTask($childTid);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line">$scheduler-&gt;newTask(task());</div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure>
<p>这将输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Parent task 1 iteration 1.</div><div class="line">Child task 2 still alive!</div><div class="line">Parent task 1 iteration 2.</div><div class="line">Child task 2 still alive!</div><div class="line">Parent task 1 iteration 3.</div><div class="line">Child task 2 still alive!</div><div class="line">Parent task 1 iteration 4.</div><div class="line">Parent task 1 iteration 5.</div><div class="line">Parent task 1 iteration 6.</div></pre></td></tr></table></figure>
<p>子任务在三次迭代后被清除，不再输出“Child is still alive“。有人可能会指出这并不是真正的父子关系，因为在父任务结束运行后，子任务仍然可以继续运行。甚至子任务也可以终止父任务。也许有人可以修改一下调度器，实现一个更有层次的任务结构，不过在本文中我们不会去做这件事。</p>
<p>还有很多进程管理调用可以去实现，比如 <code>wait</code> （等待直至某个任务执行完成），<code>exec</code> （用于替代当前任务）还有 <code>fork</code> （克隆当前运行的任务）。分路（forking）相当的酷，你可以利用 PHP 的协程来实现它，因为它们也支持克隆操作。</p>
<p>不过我会把这些留给感兴趣的读者，让我们开始下一个话题。</p>
<h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>用我们的任务管理系统来实现一个 web 服务器是一件很牛的事情。可以用一个任务用来监听 socket 建立新连接，每当一个新连接建立时，就创建一个新的任务负责处理它。</p>
<p>困难的部分在于一般的 socket 操作是阻塞的（比如读取数据）。PHP 会一直阻塞直到客户端完成数据发送。对于一个 web 服务器来说显然是不能接受的：这相当于它每次只能处理一个连接。</p>
<p>解决办法是在实际读写前，确保 socket 是“就绪”状态。为了找出哪些 socket 处于可读取或可写状态，我们可以使用 <code>stream_select</code> 方法。</p>
<p>首先，我们加入两个新的系统调用，可以使得一个任务在 socket 就绪前一直等待。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForRead</span><span class="params">($socket)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(</div><div class="line">    <span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> <span class="title">use</span> <span class="params">($socket)</span> </span>&#123;</div><div class="line">      $scheduler-&gt;waitForRead($socket, $task);</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitForWrite</span><span class="params">($socket)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SystemCall(</div><div class="line">    <span class="function"><span class="keyword">function</span><span class="params">(Task $task, Scheduler $scheduler)</span> <span class="title">use</span> <span class="params">($socket)</span> </span>&#123;</div><div class="line">      $scheduler</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些系统调用就是调度器中对应方法的代理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// resourceID =&gt; [socket, tasks]</span></div><div class="line"><span class="keyword">protected</span> $waitingForRead = [];</div><div class="line"><span class="keyword">protected</span> $waitingForWrite = [];</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForRead</span><span class="params">($socket, Task $task)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;waitingForRead[(int) $socket])) &#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;waitingForRead[(int) $socket][<span class="number">1</span>][] = $task;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;waitingForRead[(int) $socket] = [$socket, [$task]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForWrite</span><span class="params">($socket, Task $task)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;waitForWrite[(int) $socket])) &#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;waitingForWrite[(int) $socket][<span class="number">1</span>][] = $task;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;waitingForWrite[(int) $socket] = [$socket, [$task]];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>waitingForRead</code> 和 <code>waitingForWrite</code> 两个属性用于记录被等待的 socket 和等待它们的任务。下面这个方法很有趣，它实现了检查 socket 的就绪状态和重排对应任务的功能：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPoll</span><span class="params">($timeout)</span> </span>&#123;</div><div class="line">  $rSocks = [];</div><div class="line">  <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;waitingForRead <span class="keyword">as</span> <span class="keyword">list</span>($socket)) &#123;</div><div class="line">    $rSocks[] = $socket;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  $wSocks = [];</div><div class="line">  <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;waitingForWrite <span class="keyword">as</span> <span class="keyword">list</span>($sockets)) &#123;</div><div class="line">    $wSocks[] = $socket;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  $eSocks = []; <span class="comment">// dummy</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (!stream_select($rSocks, $wSocks, $eSocks, $timeout)) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">foreach</span> ($rSocks <span class="keyword">as</span> $socket) &#123;</div><div class="line">    <span class="keyword">list</span>(, $tasks) = <span class="keyword">$this</span>-&gt;waitingForRead[(int) $socket];</div><div class="line">    <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;waitingForRead[(int) $socket]);</div><div class="line">    </div><div class="line">    <span class="keyword">foreach</span> ($tasks <span class="keyword">as</span> $task) &#123;</div><div class="line">      <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>stream_select</code> 函数接受读／写／排除的 sockets 数组作为检验参数（忽略最后一个数组中的）。这些数组都是引用传参，执行完成后函数会留下状态发生变化的那些。然后我们就可以遍历这些数组，并且重排那些与之关联的任务了。</p>
<p>为了规律地执行上面的轮询操作，我们要在调度器中加入一个特别的任务：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPollTask</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">      <span class="keyword">$this</span>-&gt;ioPoll(<span class="keyword">null</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">$this</span>-&gt;ioPoll(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个任务需要在某处被加入调度，比如可以在 <code>run()</code> 方法开始处加入 <code>$this-&gt;newTask($this-&gt;ioPollTask())</code> 。然后它就会像其它的任务一样工作，每个完整的任务循环中执行一次（这不一定是最好的处理方案）。<code>ioPollTask</code> 会调用 <code>ioPoll</code> ，且超时参数设置为 <code>0</code> ，使得 <code>stream_select</code> 函数可以立即返回（不会阻塞）。</p>
<p>只有当任务队列为空时，我们给超时参数传入 <code>null</code> ，使得它会阻塞直到某个 socket 就绪。如果不这样做，就会使得轮询任务不断地被执行直到产生一个新连接。这会造成 CPU 达到 100% 的使用率。所以让操作系统在此等待会更有效率。</p>
<p>现在，要完成服务器代码相对容易很多：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">server</span><span class="params">($port)</span> </span>&#123;</div><div class="line">  <span class="keyword">echo</span> <span class="string">"Strating server as port $port...\n"</span>;</div><div class="line">  </div><div class="line">  $socket = @stream_socket_server(<span class="string">"tcp://localhost:$port"</span>, $errNo, $errStr);</div><div class="line">  <span class="keyword">if</span> (!$socket) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>($errStr, $errNo);</div><div class="line">  </div><div class="line">  stream_set_blocking($socket, <span class="number">0</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> waitForRead($socket);</div><div class="line">    $clientSocket = stream_socket_accept($socket, <span class="number">0</span>);</div><div class="line">    <span class="keyword">yield</span> newTask(handleClient($clientSocket));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClient</span><span class="params">($socket)</span> </span>&#123;</div><div class="line">  <span class="keyword">yield</span> waitForRead($socket);</div><div class="line">  $data = fread($socket, <span class="number">8192</span>);</div><div class="line">  </div><div class="line">  $msg = <span class="string">"Received following request:\n\n$data"</span>;</div><div class="line">  $msgLength = strlen($msg);</div><div class="line">  </div><div class="line">  $response = <span class="string">&lt;&lt;&lt;RES</span></div><div class="line">HTTP/1.1 200 OK\r</div><div class="line">Content-Type: text/plain\r</div><div class="line">Content-Length: <span class="subst">$msgLength</span>\r</div><div class="line">Connection: close\r</div><div class="line">\r</div><div class="line"><span class="subst">$msg</span></div><div class="line">RES;</div><div class="line">  <span class="keyword">yield</span> waitForWrite($socket);</div><div class="line">  fwrite($socket, $reponse);</div><div class="line">  </div><div class="line">  fclose($socket);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line">$scheduler-&gt;newTask(server(<span class="number">8000</span>));</div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure>
<p>这段代码能接受 <code>localhost:8000</code> 的连接，并发回一个 HTTP 响应，包含它发送过来的内容。现实情况则要复杂得多（讨论如何恰当地处理 HTTP 请求已经超出了本文的范围）。以上代码仅是一个通常意义上的示例。</p>
<p>你可以用 <code>ab -n 1000 -c 100 localhost:8000/</code> 来测试这个服务代码。这可以一百并发地发送一万次请求。在这种压力下我得到的响应时长为十毫秒。但会有一些问题，某些请求处理得<em>非常慢</em>（约五秒），导致总吞吐量只有每秒两千次请求（如果一个请求只耗时十毫秒的话，应当接近每秒一万次请求）。采用更高的并发时（比如 <code>-c 500</code> ）绝大多数时候还是工作正常，除了某些连接抛出了“Connection reset by peer“的错误。由于我对这些底层的 socket 事情了解较少，所以也没去探究其原因。</p>
<h2 id="栈式协程"><a href="#栈式协程" class="headerlink" title="栈式协程"></a>栈式协程</h2><p>如果你想用我们的调度系统构建一个更大的系统，那么很快就会遇到这个问题：我们习惯于将代码拆散为更小的功能函数进行调用。使用协程时却无法做到了。比如考虑一下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoTimes</span><span class="params">($msg, $max)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $max; ++$i) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"$msg iteration $i\n"</span>;</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">  echoTimes(<span class="string">'foo'</span>, <span class="number">10</span>); <span class="comment">// 输出10次 foo</span></div><div class="line">  <span class="keyword">echo</span> <span class="string">"---\n"</span>;</div><div class="line">  echoTimes(<span class="string">'bar'</span>, <span class="number">5</span>); <span class="comment">// 输出5次 bar</span></div><div class="line">  <span class="keyword">yield</span>; <span class="comment">// 强制转换为一个协程</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line">$scheduler-&gt;newTask(task());</div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure>
<p>代码想要把反复用到的“输出 n 次”这段代码作为一个独立的协程，然后在主任务中调用它。但是却不能正常工作。就像文章开头提到的生成器（或协程）本身不做任何事情，它只是返回一个对象。上面这个例子中即印证了此事。<code>echoTimes</code> 调用除了返回一个（未使用）的协程对象外，什么也不会做。</p>
<p>为了使其能正常工作，我们需要为协程对象写一个小小的包裹类。我将其命名为“栈式协程”（ stacked coroutine ），因为它会管理一个嵌套的协程调用栈。它可以通过 yield 调用子协程：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$retval = (<span class="keyword">yield</span> someCoroutine($foo, $bar));</div></pre></td></tr></table></figure>
<p>子协程也能返回数据，还是使用 <code>yield</code> :</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">yield</span> retval(<span class="string">"I'm a return value!"</span>);</div></pre></td></tr></table></figure>
<p>这个 <code>retval</code> 函数仅仅只是返回一个数据的包裹对象，表明自己是一个返回值：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineReturnValue</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> $value;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($value)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;value = $value;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">retval</span><span class="params">($value)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CoroutineReturnValue($value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要将一个协程转化为一个栈式协程（支持子调用），我们还需要另一个函数（显然又是一个协程）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span><span class="params">(Generator $gen)</span> </span>&#123;</div><div class="line">  $stack = <span class="keyword">new</span> SplStack;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line">    $value = $gen-&gt;current();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ($value <span class="keyword">instanceof</span> Generator) &#123;</div><div class="line">      $stack-&gt;push($gen);</div><div class="line">      $gen = $value;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    $isReturnValue = $value <span class="keyword">instanceof</span> CoroutineReturnValue;</div><div class="line">    <span class="keyword">if</span> (!$gen-&gt;valid() || $isReturnValue) &#123;</div><div class="line">      <span class="keyword">if</span>($stack-&gt;isEmpty()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      $gen = $stack-&gt;pop();</div><div class="line">      $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="keyword">NULL</span>);</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    $gen-&gt;send(<span class="keyword">yield</span> $gen-&gt;key() =&gt; $value);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法充当着调用者和当前运行的子协程的代理。它是在这一行 <code>$gen-&gt;send(yield $gen-&gt;key() =&gt; $value);</code> 进行处理的。此外还检验返回值是否生成器，如果是就开始执行它，并将之前的协程压入栈中。一旦得到一个 <code>CoroutineReturnValue</code> 就会从栈中取出，继续执行之前的协程。</p>
<p>要使栈式协程在任务中可以使用，<code>Task</code> 构造器中的 <code>$this-&gt;coroutine = $coroutine;</code> 这一行需要被替换为 <code>$this-&gt;coroutine = stackedCoroutine($coroutine);</code> 。</p>
<p>现在我们可以改进 web 服务器的例子，把 wait+read （还有 wait+write 和 wait+accept）这些动作组合为函数。我将用一个类把相关功能整合在一起：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoSocket</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> $socket;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($socket)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;socket = $socket;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">accept</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">yield</span> waitForRead(<span class="keyword">$this</span>-&gt;socket);</div><div class="line">    <span class="keyword">yield</span> retval(<span class="keyword">new</span> CoSocket(stream_socket_accept(<span class="keyword">$this</span>-&gt;socket, <span class="number">0</span>)));</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span><span class="params">($size)</span> </span>&#123;</div><div class="line">    <span class="keyword">yield</span> waitForRead(<span class="keyword">$this</span>-&gt;socket);</div><div class="line">    <span class="keyword">yield</span> retval(fread(<span class="keyword">$this</span>-&gt;socket, $size));</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">($string)</span> </span>&#123;</div><div class="line">    <span class="keyword">yield</span> waitForWrite(<span class="keyword">$this</span>-&gt;socket);</div><div class="line">    fwrite(<span class="keyword">$this</span>-&gt;socket, $string);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">    @fclose(<span class="keyword">$this</span>-&gt;socket);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样服务器代码可以写得更加清晰了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">server</span><span class="params">($port)</span> </span>&#123;</div><div class="line">  <span class="keyword">echo</span> <span class="string">"Starting server at port $port...\n"</span>;</div><div class="line">  </div><div class="line">  $socket = @stream_socket_server(<span class="string">"tcp://localhost:$port"</span>, $errNo, $errStr);</div><div class="line">  <span class="keyword">if</span> (!$socket) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>($errStr, $errNo);</div><div class="line">  </div><div class="line">  stream_set_blocking($socket, <span class="number">0</span>);</div><div class="line">  </div><div class="line">  $socket = <span class="keyword">new</span> CoSocket($socket);</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> newTask(</div><div class="line">      handleClient(<span class="keyword">yield</span> $socket-&gt;accept())</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClient</span><span class="params">($socket)</span> </span>&#123;</div><div class="line">  $data = (<span class="keyword">yield</span> $socket-&gt;read(<span class="number">8192</span>));</div><div class="line">  </div><div class="line">  $msg = <span class="string">"Received following request:\n\n$data"</span>;</div><div class="line">  $msgLength = strlen($msg);</div><div class="line">  </div><div class="line">  $response = <span class="string">&lt;&lt;&lt;RES</span></div><div class="line">HTTP/1.1 200 OK\r</div><div class="line">Content-Type: text/plain\r</div><div class="line">Content-Length: <span class="subst">$msgLength</span>\r</div><div class="line">Connection: close\r</div><div class="line">\r</div><div class="line"><span class="subst">$msg</span></div><div class="line">RES;</div><div class="line">  </div><div class="line">  <span class="keyword">yield</span> $socket-&gt;write($response);</div><div class="line">  <span class="keyword">yield</span> $socket-&gt;close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>作为一名 NB 的程序员，你一定已经注意到了，上面的例子都缺少错误处理机制。差不多 socket 的每一个操作都可能失败并造成错误的。我显然做了这些事，不过错误处理实在是太无聊（ socket 的更是如此！），而且很容易就使得代码量成倍地增长。</p>
<p>不过我还是愿意分享一下协程的一般错误处理方式：协程提供了使用 <code>throw()</code> 方法在它们内部抛出异常的能力。</p>
<p><code>throw()</code> 方法接受一个异常实例，并在协程的当前中断点抛出。考虑以下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">echo</span> <span class="string">"Foo\n"</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Exception: &#123;$e-&gt;getMessage()&#125;\n"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">echo</span> <span class="string">"Bar\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$gen = gen();</div><div class="line">$gen-&gt;rewind(); <span class="comment">// 输出 "Foo"</span></div><div class="line">$gen-&gt;throw(<span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'Test'</span>)); <span class="comment">// 输出 "Exception: Test" 和 "Bar"</span></div></pre></td></tr></table></figure>
<p>对于我们的目的来说这样很 NB ，因为我们可以在系统调用和子协程中抛出异常了。对于系统调用来说 <code>Scheduler::run()</code> 方法需要一些小小的调整：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($retval <span class="keyword">instanceof</span> SystemCall) &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    $retval($task, <span class="keyword">$this</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</div><div class="line">    $task-&gt;setException($e);</div><div class="line">    <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Task</code> 类也需要处理 <code>throw</code> 调用的情况了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keyword">protected</span> $exception = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setException</span><span class="params">($exception)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;exception = $exception;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</div><div class="line">      <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</div><div class="line">    &#125; <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;exception) &#123;</div><div class="line">      $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;throw(<span class="keyword">$this</span>-&gt;exception);</div><div class="line">      <span class="keyword">$this</span>-&gt;exception = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">return</span> $retval;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendValue);</div><div class="line">      <span class="keyword">$this</span>-&gt;sendValue = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">return</span> $retval;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>走一个：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">yield</span> killTask(<span class="number">500</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'Tried to kill task 500 but failed: '</span>, $e-&gt;getMessage(), <span class="string">"\n"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可惜这还不能正常工作，因为 <code>stackedCoroutine</code> 函数还没有正确地处理异常情况。需要修改一下代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackedCoroutine</span><span class="params">(Generator $gen)</span> </span>&#123;</div><div class="line">  $stack = <span class="keyword">new</span> SplStack;</div><div class="line">  $exception = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (;;) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> ($exception) &#123;</div><div class="line">        $gen-&gt;throw($exception);</div><div class="line">        $exception = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      $value = $gen-&gt;current();</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> ($value <span class="keyword">instanceof</span> Generator) &#123;</div><div class="line">        $stack-&gt;push($gen);</div><div class="line">        $gen = $value;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      $isReturnValue = $value <span class="keyword">instanceof</span> CoroutineReturnValue;</div><div class="line">      <span class="keyword">if</span> (!$gen-&gt;valid() || $isReturnValue) &#123;</div><div class="line">        <span class="keyword">if</span> ($stack-&gt;isEmpty()) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        $gen = $stack-&gt;pop();</div><div class="line">        $gen-&gt;send($isReturnValue ? $value-&gt;getValue() : <span class="keyword">NULL</span>);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        $sendValue = (<span class="keyword">yield</span> $gen-&gt;key() =&gt; $value);</div><div class="line">      &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</div><div class="line">        $gen-&gt;throw($e);</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      $gen-&gt;send($sendValue);</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</div><div class="line">      <span class="keyword">if</span> ($stack-&gt;isEmpty()) &#123;</div><div class="line">        <span class="keyword">throw</span> $e;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      $gen = $stack-&gt;pop();</div><div class="line">      $exception = $e;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们创建了一个多任务协作的任务调度器，同时具备“系统调用”、执行异步 IO 操作和错误处理的能力。最酷的一点是这些代码看起来是完全同步的，尽管它执行了许多异步操作。如果你想从某个 socket 中读取数据，你既不必传递回调函数，也不必注册事件监听器。取而代之的你只需要写一句 <code>yield $socket-&gt;read()</code> 。与你常写的代码基本一致，仅仅只用在前面加一个 <code>yield</code> 。</p>
<p>当我第一次听说这些概念时，我发现这个概念真的 NB ，并且直接促使我在 PHP 中也实现这些特性。同时我发现协程真的容易让人担心。协程的使用，让完美的代码和糟糕的代码之间仅有一线之隔。对我而言，很难评价像上文一样的方式去写异步代码是否真的有益。</p>
<p>无论如何，我都认为这是一个有趣的话题，希望你也感兴趣。期待您的评论 : - )</p>
<blockquote>
<p>翻译自：<a href="https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html" target="_blank" rel="external">Cooperative multitasking using coroutines (in PHP!)</a></p>
<p>原文作者：<a href="https://nikic.github.io/aboutMe.html" target="_blank" rel="external">Nikita Popov</a></p>
</blockquote>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/03/understand-js-closure/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          搞不明白的 Javascript 闭包
        
      </div>
    </a>
  
  
    <a href="/2016/06/28/Laravel-5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Laravel 5 流程简析</div>
    </a>
  
</nav>

  
</article>

<script type='text/javascript'>window.notIndexPage = true;</script>


<section id="comments">
  <div id="disqus_thread">
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'imzvz'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
  </div>
</section>
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>
      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	Linked with:&nbsp;&nbsp;&nbsp; 
	<a href="http://mritd.me" target="_blank">mritd.me</a>&nbsp;&nbsp;&nbsp;
	<a href="https://www.mghio.cn" target="_blank">mghio's blog</a>&nbsp;&nbsp;&nbsp;
	<a href="https://sillydong.com" target="_blank">傻东の学习笔记</a>&nbsp;&nbsp;&nbsp;
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
</nav>
    
<script>
  var disqus_shortname = 'imzvz';
  
  var disqus_url = 'http://log.zvz.im/2016/07/01/PHP-Coroutine/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>

<script>
  if(window.notIndexPage)
  $(function(){
    $.get('//manage.zvz.im/api/posts/adv', function(res) {
      if(res.data.length) {
        $.each(res.data, function(idx, adv) {
          if(idx == 0) {
            if($('h2:first').length > 0) {
              $(adv).insertBefore('h2:first');
              return;
            }
          }
          $(adv).insertAfter('.article-inner');
        });
      }
    });
  });
</script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/require.min.js"></script>
<script src="/js/script.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>